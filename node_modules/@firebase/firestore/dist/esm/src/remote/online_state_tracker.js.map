{"version":3,"sources":["../src/remote/online_state_tracker.ts"],"names":[],"mappings":"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","file":"online_state_tracker.js","sourcesContent":["/**\n * Copyright 2018 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { OnlineState } from '../core/types';\nimport * as log from '../util/log';\nimport { assert } from '../util/assert';\nimport { AsyncQueue, TimerId } from '../util/async_queue';\nimport { CancelablePromise } from '../util/promise';\n\nconst LOG_TAG = 'OnlineStateTracker';\n\n// To deal with transient failures, we allow multiple stream attempts before\n// giving up and transitioning from OnlineState.Unknown to Offline.\nconst MAX_WATCH_STREAM_FAILURES = 2;\n\n// To deal with stream attempts that don't succeed or fail in a timely manner,\n// we have a timeout for OnlineState to reach Online or Offline.\n// If the timeout is reached, we transition to Offline rather than waiting\n// indefinitely.\nconst ONLINE_STATE_TIMEOUT_MS = 10 * 1000;\n\n/**\n * A component used by the RemoteStore to track the OnlineState (that is,\n * whether or not the client as a whole should be considered to be online or\n * offline), implementing the appropriate heuristics.\n *\n * In particular, when the client is trying to connect to the backend, we\n * allow up to MAX_WATCH_STREAM_FAILURES within ONLINE_STATE_TIMEOUT_MS for\n * a connection to succeed. If we have too many failures or the timeout elapses,\n * then we set the OnlineState to Offline, and the client will behave as if\n * it is offline (get()s will return cached data, etc.).\n */\nexport class OnlineStateTracker {\n  /** The current OnlineState. */\n  private state = OnlineState.Unknown;\n\n  /**\n   * A count of consecutive failures to open the stream. If it reaches the\n   * maximum defined by MAX_WATCH_STREAM_FAILURES, we'll set the OnlineState to\n   * Offline.\n   */\n  private watchStreamFailures = 0;\n\n  /**\n   * A timer that elapses after ONLINE_STATE_TIMEOUT_MS, at which point we\n   * transition from OnlineState.Unknown to OnlineState.Offline without waiting\n   * for the stream to actually fail (MAX_WATCH_STREAM_FAILURES times).\n   */\n  private onlineStateTimer: CancelablePromise<void> | null = null;\n\n  /**\n   * Whether the client should log a warning message if it fails to connect to\n   * the backend (initially true, cleared after a successful stream, or if we've\n   * logged the message already).\n   */\n  private shouldWarnClientIsOffline = true;\n\n  constructor(\n    private asyncQueue: AsyncQueue,\n    private onlineStateHandler: (onlineState: OnlineState) => void\n  ) {}\n\n  /**\n   * Called by RemoteStore when a watch stream is started (including on each\n   * backoff attempt).\n   *\n   * If this is the first attempt, it sets the OnlineState to Unknown and starts\n   * the onlineStateTimer.\n   */\n  handleWatchStreamStart(): void {\n    if (this.watchStreamFailures === 0) {\n      this.setAndBroadcast(OnlineState.Unknown);\n\n      assert(\n        this.onlineStateTimer === null,\n        `onlineStateTimer shouldn't be started yet`\n      );\n      this.onlineStateTimer = this.asyncQueue.enqueueAfterDelay(\n        TimerId.OnlineStateTimeout,\n        ONLINE_STATE_TIMEOUT_MS,\n        () => {\n          this.onlineStateTimer = null;\n          assert(\n            this.state === OnlineState.Unknown,\n            'Timer should be canceled if we transitioned to a different state.'\n          );\n          log.debug(\n            LOG_TAG,\n            `Watch stream didn't reach online or offline within ` +\n              `${ONLINE_STATE_TIMEOUT_MS}ms. Considering client offline.`\n          );\n          this.logClientOfflineWarningIfNecessary();\n          this.setAndBroadcast(OnlineState.Offline);\n\n          // NOTE: handleWatchStreamFailure() will continue to increment\n          // watchStreamFailures even though we are already marked Offline,\n          // but this is non-harmful.\n\n          return Promise.resolve();\n        }\n      );\n    }\n  }\n\n  /**\n   * Updates our OnlineState as appropriate after the watch stream reports a\n   * failure. The first failure moves us to the 'Unknown' state. We then may\n   * allow multiple failures (based on MAX_WATCH_STREAM_FAILURES) before we\n   * actually transition to the 'Offline' state.\n   */\n  handleWatchStreamFailure(): void {\n    if (this.state === OnlineState.Online) {\n      this.setAndBroadcast(OnlineState.Unknown);\n\n      // To get to OnlineState.Online, set() must have been called which would\n      // have reset our heuristics.\n      assert(this.watchStreamFailures === 0, 'watchStreamFailures must be 0');\n      assert(this.onlineStateTimer === null, 'onlineStateTimer must be null');\n    } else {\n      this.watchStreamFailures++;\n      if (this.watchStreamFailures >= MAX_WATCH_STREAM_FAILURES) {\n        this.clearOnlineStateTimer();\n        this.logClientOfflineWarningIfNecessary();\n        this.setAndBroadcast(OnlineState.Offline);\n      }\n    }\n  }\n\n  /**\n   * Explicitly sets the OnlineState to the specified state.\n   *\n   * Note that this resets our timers / failure counters, etc. used by our\n   * Offline heuristics, so must not be used in place of\n   * handleWatchStreamStart() and handleWatchStreamFailure().\n   */\n  set(newState: OnlineState): void {\n    this.clearOnlineStateTimer();\n    this.watchStreamFailures = 0;\n\n    if (newState === OnlineState.Online) {\n      // We've connected to watch at least once. Don't warn the developer\n      // about being offline going forward.\n      this.shouldWarnClientIsOffline = false;\n    }\n\n    this.setAndBroadcast(newState);\n  }\n\n  private setAndBroadcast(newState: OnlineState): void {\n    if (newState !== this.state) {\n      this.state = newState;\n      this.onlineStateHandler(newState);\n    }\n  }\n\n  private logClientOfflineWarningIfNecessary(): void {\n    if (this.shouldWarnClientIsOffline) {\n      log.error('Could not reach Firestore backend.');\n      this.shouldWarnClientIsOffline = false;\n    }\n  }\n\n  private clearOnlineStateTimer(): void {\n    if (this.onlineStateTimer !== null) {\n      this.onlineStateTimer.cancel();\n      this.onlineStateTimer = null;\n    }\n  }\n}\n"]}